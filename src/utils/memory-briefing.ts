/**
 * Memory Briefing Writer
 *
 * Generates a curated MEMORY.md briefing from claude-mem observations.
 * Uses tagged sections to coexist with Claude Code's own auto memory writes.
 *
 * Strategy: Prepend <claude-mem-briefing> section to top of MEMORY.md.
 * Re-inject on every SessionStart to handle overwrites by Claude.
 */

import { existsSync, readFileSync, writeFileSync, mkdirSync } from 'fs';
import { dirname } from 'path';

export const BRIEFING_START_TAG = '<claude-mem-briefing>';
export const BRIEFING_END_TAG = '</claude-mem-briefing>';

// Leave headroom below the 200-line system prompt truncation limit
const MAX_LINES = 180;

export interface ObservationSummary {
  title: string;
  type: string;
  time: string;
}

/**
 * Build briefing markdown from recent observations.
 * Kept concise to fit within the 200-line auto memory limit.
 */
export function buildBriefingContent(
  projectName: string,
  observations: ObservationSummary[]
): string {
  const lines: string[] = [];
  lines.push(`# ${projectName} — Briefing`);
  lines.push('');
  lines.push('*Auto-generated by claude-mem. Use MCP search for full history.*');
  lines.push('');

  if (observations.length === 0) {
    lines.push('No recent observations.');
    return lines.join('\n');
  }

  lines.push('## Recent Activity');
  lines.push('');

  for (const obs of observations) {
    const line = `- **${obs.time}** ${obs.title}`;
    lines.push(line);
    if (lines.length >= MAX_LINES - 5) {
      const remaining = observations.length - (lines.length - 6);
      lines.push(`- ... and ${remaining} more (use MCP search)`);
      break;
    }
  }

  return lines.join('\n');
}

/**
 * Replace only the claude-mem-briefing section in existing content.
 * Preserves any content Claude Code or the user wrote outside the tags.
 */
function replaceMemoryBriefingSection(existing: string, newContent: string): string {
  const startIdx = existing.indexOf(BRIEFING_START_TAG);
  const endIdx = existing.indexOf(BRIEFING_END_TAG);

  if (startIdx !== -1 && endIdx !== -1) {
    return existing.substring(0, startIdx) +
      `${BRIEFING_START_TAG}\n${newContent}\n${BRIEFING_END_TAG}` +
      existing.substring(endIdx + BRIEFING_END_TAG.length);
  }

  // No existing tags — prepend (so claude-mem content appears first in system prompt)
  return `${BRIEFING_START_TAG}\n${newContent}\n${BRIEFING_END_TAG}\n\n${existing}`;
}

/**
 * Write briefing content to a MEMORY.md file.
 * Creates the directory if it doesn't exist.
 * Preserves content outside <claude-mem-briefing> tags.
 */
export function writeMemoryBriefing(memoryPath: string, briefingContent: string): void {
  const dir = dirname(memoryPath);
  if (!existsSync(dir)) {
    mkdirSync(dir, { recursive: true });
  }

  let existing = '';
  if (existsSync(memoryPath)) {
    existing = readFileSync(memoryPath, 'utf-8');
  }

  const final = replaceMemoryBriefingSection(existing, briefingContent);
  writeFileSync(memoryPath, final);
}
